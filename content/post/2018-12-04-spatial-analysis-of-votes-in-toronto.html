---
title: Spatial analysis of votes in Toronto
author: Matthew Routley
date: '2018-12-04'
slug: spatial-analysis-of-votes-in-toronto
categories:
  - election
  - code
tags: []
---



<p>This is a “behind the scenes” elaboration of the geospatial analysis in our <a href="http://www.psephoanalytics.ca/2018/11/reviewing-our-2018-mayoral-race.html">recent post</a> on evaluating our predictions for the 2018 mayoral election in Toronto. This was my first, serious use of the new <a href="https://r-spatial.github.io/sf/"><code>sf</code> package</a> for geospatial analysis. I found the package much easier to use than some of my previous workflows for this sort of analysis, especially given its integration with the <a href="https://www.tidyverse.org/">tidyverse</a>.</p>
<p>We start by downloading the <a href="https://www.toronto.ca/city-government/data-research-maps/open-data/open-data-catalogue/#370e7072-0ba7-e477-121e-78ba5dac9649">shapefile for voting locations</a> from the City of Toronto’s <a href="https://www.toronto.ca/city-government/data-research-maps/open-data/">Open Data portal</a> and reading it with the <code>read_sf</code> function. Then, we pipe it to <code>st_transform</code> to set the appropriate <a href="https://en.wikipedia.org/wiki/Map_projection">projection</a> for the data. In this case, this isn’t strictly necessary, since the shapefile is already in the right projection. But, I tend to do this for all shapefiles to avoid any oddities later.</p>
<pre class="r"><code>download.file(&quot;http://opendata.toronto.ca/gcc/voting_location_2018_wgs84.zip&quot;,
                destfile = &quot;data-raw/voting_location_2018_wgs84.zip&quot;, quiet = TRUE)
unzip(&quot;data-raw/voting_location_2018_wgs84.zip&quot;, exdir=&quot;data-raw/voting_location_2018_wgs84&quot;)
toronto_locations &lt;- sf::read_sf(&quot;data-raw/voting_location_2018_wgs84&quot;, 
                                 layer = &quot;VOTING_LOCATION_2018_WGS84&quot;) %&gt;%
  sf::st_transform(crs = &quot;+init=epsg:4326&quot;)
toronto_locations</code></pre>
<pre><code>## Simple feature collection with 1700 features and 13 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -79.61937 ymin: 43.59062 xmax: -79.12531 ymax: 43.83052
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
## # A tibble: 1,700 x 14
##    POINT_ID FEAT_CD FEAT_C_DSC PT_SHRT_CD PT_LNG_CD POINT_NAME VOTER_CNT
##       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;          &lt;int&gt;
##  1    10190 P       Primary    056        10056     &lt;NA&gt;              37
##  2    10064 P       Primary    060        10060     &lt;NA&gt;             532
##  3    10999 S       Secondary  058        10058     Malibu           661
##  4    11342 P       Primary    052        10052     &lt;NA&gt;            1914
##  5    10640 P       Primary    047        10047     The Summit       956
##  6    10487 S       Secondary  061        04061     White Eag…        51
##  7    11004 P       Primary    063        04063     Holy Fami…      1510
##  8    11357 P       Primary    024        11024     Rosedale …      1697
##  9    12044 P       Primary    018        05018     Weston Pu…      1695
## 10    11402 S       Secondary  066        04066     Elm Grove…        93
## # ... with 1,690 more rows, and 7 more variables: OBJECTID &lt;dbl&gt;,
## #   ADD_FULL &lt;chr&gt;, X &lt;dbl&gt;, Y &lt;dbl&gt;, LONGITUDE &lt;dbl&gt;, LATITUDE &lt;dbl&gt;,
## #   geometry &lt;POINT [°]&gt;</code></pre>
<p>The file has 1700 rows of data across 14 columns. The first 13 columns are data within the original shapefile. The last column is a <a href="https://www.rstudio.com/resources/videos/how-to-work-with-list-columns/">list column</a> that is added by <code>sf</code> and contains the geometry of the location. This specific design feature is what makes an <code>sf</code> object work really well with the rest of the tidyverse: the geographical details are just a column in the data frame. This makes the data much easier to work with than in other approaches, where the data is contained within an <code>@data</code> slot of an object.</p>
<p>Plotting the data is straightforward, since <code>sf</code> objects have a <code>plot</code> function. Here’s an example where we plot the number of voters (<code>VOTER_CNT</code>) at each location. If you squint just right, you can see the general outline of Toronto in these points.</p>
<p><img src="/post/2018-12-04-spatial-analysis-of-votes-in-toronto_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<p>What we want to do next is use the voting location data to aggregate the votes cast at each location into census tracts. This then allows us to associate census characteristics (like age and income) with the pattern of votes and develop our statistical relationships for predicting voter behaviour.</p>
<p>We’ll split this into several steps. The first is downloading and reading the census tract shapefile.</p>
<pre class="r"><code>download.file(&quot;http://www12.statcan.gc.ca/census-recensement/2011/geo/bound-limit/files-fichiers/gct_000b11a_e.zip&quot;,
                destfile = &quot;data-raw/gct_000b11a_e.zip&quot;, quiet = TRUE)
unzip(&quot;data-raw/gct_000b11a_e.zip&quot;, exdir=&quot;data-raw/gct&quot;)
census_tracts &lt;- sf::read_sf(&quot;data-raw/gct&quot;, layer = &quot;gct_000b11a_e&quot;) %&gt;%
  sf::st_transform(crs = &quot;+init=epsg:4326&quot;)</code></pre>
<p>Now that we have it, all we really want are the census tracts in Toronto (the shapefile includes census tracts across Canada). We achieve this by intersecting the Toronto voting locations with the census tracts using standard R subsetting notation.</p>
<pre class="r"><code>to_census_tracts &lt;- census_tracts[toronto_locations,]</code></pre>
<p>And, we can plot it to see how well the intersection worked. This time we’ll plot the CTUID, which is the unique identifier for each census tract. This doesn’t mean anything in this context, but adds some nice colour to the plot.</p>
<pre class="r"><code>plot(to_census_tracts[&quot;CTUID&quot;])</code></pre>
<p><img src="/post/2018-12-04-spatial-analysis-of-votes-in-toronto_files/figure-html/plot_intersection-1.png" width="672" /></p>
<p>Now you can really see the shape of Toronto, as well as the size of each census tract.</p>
<p>Next we need to manipulate the voting data to get votes received by major candidates in the 2018 election. We take these data from the <a href="https://github.com/Psepho/toVotes"><code>toVotes</code> package</a> and arbitrarily set the threshold for major candidates to receiving at least 100,000 votes. This yields our two main candidates: John Tory and Jennifer Keesmaat.</p>
<pre class="r"><code>major_candidates &lt;- toVotes %&gt;% 
  dplyr::filter(year == 2018) %&gt;%
  dplyr::group_by(candidate) %&gt;%
  dplyr::summarise(votes = sum(votes)) %&gt;%
  dplyr::filter(votes &gt; 100000) %&gt;%
  dplyr::select(candidate)
major_candidates</code></pre>
<pre><code>## # A tibble: 2 x 1
##   candidate        
##   &lt;chr&gt;            
## 1 Keesmaat Jennifer
## 2 Tory John</code></pre>
<p>Given our goal of aggregating the votes received by each candidate into census tracts, we need a data frame that has each candidate in a separate column. We start by joining the major candidates table to the votes table. In this case, we also filter the votes to 2018, since John Tory has been a candidate in more than one election. Then we use the <code>tidyr</code> package to convert the table from long (with one candidate column) to wide (with a column for each candidate).</p>
<pre class="r"><code>spread_votes &lt;- toVotes %&gt;%
  tibble::as.tibble() %&gt;% 
  dplyr::filter(year == 2018) %&gt;%
  dplyr::right_join(major_candidates) %&gt;%
  dplyr::select(-type, -year) %&gt;%
  tidyr::spread(candidate, votes)
spread_votes</code></pre>
<pre><code>## # A tibble: 1,800 x 4
##     ward  area `Keesmaat Jennifer` `Tory John`
##    &lt;int&gt; &lt;int&gt;               &lt;dbl&gt;       &lt;dbl&gt;
##  1     1     1                  66         301
##  2     1     2                  72         376
##  3     1     3                  40         255
##  4     1     4                  24         161
##  5     1     5                  51         211
##  6     1     6                  74         372
##  7     1     7                  70         378
##  8     1     8                  10          77
##  9     1     9                  11          82
## 10     1    10                  12          76
## # ... with 1,790 more rows</code></pre>
<p>Our last step before finally aggregating to census tracts is to join the <code>spread_votes</code> table with the <code>toronto_locations</code> data. This requires pulling the ward and area identifiers from the <code>PT_LNG_CD</code> column of the <code>toronto_locations</code> data frame which we do with some <code>stringr</code> functions. While we’re at it, we also update the candidate names to just surnames.</p>
<pre class="r"><code>to_geo_votes &lt;- toronto_locations %&gt;%
  dplyr::mutate(ward = as.integer(stringr::str_sub(PT_LNG_CD, 1, 2)),
                area = as.integer(stringr::str_sub(PT_LNG_CD, -3, -1))) %&gt;%
  dplyr::left_join(spread_votes) %&gt;%
  dplyr::select(`Keesmaat Jennifer`, `Tory John`) %&gt;%
  dplyr::rename(Keesmaat = `Keesmaat Jennifer`, Tory = `Tory John`)
to_geo_votes</code></pre>
<pre><code>## Simple feature collection with 1700 features and 2 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -79.61937 ymin: 43.59062 xmax: -79.12531 ymax: 43.83052
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
## # A tibble: 1,700 x 3
##    Keesmaat  Tory             geometry
##       &lt;dbl&gt; &lt;dbl&gt;          &lt;POINT [°]&gt;
##  1       55   101 (-79.40225 43.63641)
##  2       43    53  (-79.3985 43.63736)
##  3       61    89 (-79.40028 43.63664)
##  4      296   348 (-79.39922 43.63928)
##  5      151   204 (-79.40401 43.64293)
##  6        2    11 (-79.43941 43.63712)
##  7      161   174 (-79.43511 43.63869)
##  8      221   605  (-79.38188 43.6776)
##  9       68   213 (-79.52078 43.70176)
## 10        4    14 (-79.43094 43.64027)
## # ... with 1,690 more rows</code></pre>
<p>Okay, we’re finally there. We have our census tract data in <code>to_census_tracts</code> and our voting data in <code>to_geo_votes</code>. We want to aggregate the votes into each census tract by summing the votes at each voting location within each census tract. We use the <code>aggregate</code> function for this.</p>
<pre class="r"><code>ct_votes_wide &lt;- aggregate(x = to_geo_votes, 
                           by = to_census_tracts, 
                           FUN = sum)
ct_votes_wide</code></pre>
<pre><code>## Simple feature collection with 522 features and 2 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -79.6393 ymin: 43.58107 xmax: -79.11547 ymax: 43.85539
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
## First 10 features:
##    Keesmaat Tory                       geometry
## 1       407  459 MULTIPOLYGON (((-79.39659 4...
## 2      1103 2400 MULTIPOLYGON (((-79.38782 4...
## 3       403 1117 MULTIPOLYGON (((-79.27941 4...
## 4        96  570 MULTIPOLYGON (((-79.28156 4...
## 5       169  682 MULTIPOLYGON (((-79.49104 4...
## 6       121  450 MULTIPOLYGON (((-79.54422 4...
## 7        42   95 MULTIPOLYGON (((-79.45379 4...
## 8       412  512 MULTIPOLYGON (((-79.33895 4...
## 9        83  132 MULTIPOLYGON (((-79.35427 4...
## 10       92  629 MULTIPOLYGON (((-79.44554 4...</code></pre>
<p>As a last step, to tidy up, we now convert the wide table with a column for each candidate into a long table that has just one candidate column containing the name of the candidate.</p>
<pre class="r"><code>ct_votes &lt;- tidyr::gather(ct_votes_wide, candidate, votes, -geometry)
ct_votes</code></pre>
<pre><code>## Simple feature collection with 1044 features and 2 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -79.6393 ymin: 43.58107 xmax: -79.11547 ymax: 43.85539
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
## First 10 features:
##    candidate votes                       geometry
## 1   Keesmaat   407 MULTIPOLYGON (((-79.39659 4...
## 2   Keesmaat  1103 MULTIPOLYGON (((-79.38782 4...
## 3   Keesmaat   403 MULTIPOLYGON (((-79.27941 4...
## 4   Keesmaat    96 MULTIPOLYGON (((-79.28156 4...
## 5   Keesmaat   169 MULTIPOLYGON (((-79.49104 4...
## 6   Keesmaat   121 MULTIPOLYGON (((-79.54422 4...
## 7   Keesmaat    42 MULTIPOLYGON (((-79.45379 4...
## 8   Keesmaat   412 MULTIPOLYGON (((-79.33895 4...
## 9   Keesmaat    83 MULTIPOLYGON (((-79.35427 4...
## 10  Keesmaat    92 MULTIPOLYGON (((-79.44554 4...</code></pre>
<p>Now that we have votes aggregated by census tract, we can add in many other attributes from the census data. We won’t do that here, since this post is already pretty long. But, we’ll end with a plot to show how easily <code>sf</code> integrates with <code>ggplot2</code>. This is a nice improvement from past workflows, when several steps were required. In the actual <a href="https://github.com/Psepho/to2018retrospective/blob/master/compare_pred_actual_2018.Rmd">code for the retrospective analysis</a>, I added some other plotting techniques, like cutting the response variable (votes) into equally spaced pieces and adding some more refined labels. Here, we’ll just produce a simple plot.</p>
<pre class="r"><code>ggplot2::ggplot(data = ct_votes) +
  ggplot2::geom_sf(ggplot2::aes(fill = votes)) +
  ggplot2::facet_wrap(~candidate)</code></pre>
<p><img src="/post/2018-12-04-spatial-analysis-of-votes-in-toronto_files/figure-html/map-1.png" width="672" /></p>
