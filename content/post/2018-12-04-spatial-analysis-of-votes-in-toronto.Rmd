---
title: Spatial analysis of votes in Toronto
author: Matthew Routley
date: '2018-12-04'
slug: spatial-analysis-of-votes-in-toronto
categories:
  - election
  - code
tags: []
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
devtools::install_github("psepho/toVotes", ref = "2018_mayor")
library(toVotes)
```

This is a "behind the scenes" elaboration of the geospatial analysis in our [recent post][post] on evaluating our predictions for the 2018 mayoral election in Toronto. This was my first, serious use of the new [`sf` package][sf] for geospatial analysis. I found the package much easier to use than some of my previous workflows for this sort of analysis, especially given its integration with the [tidyverse][tv].

  [post]:http://www.psephoanalytics.ca/2018/11/reviewing-our-2018-mayoral-race.html
  [sf]:https://r-spatial.github.io/sf/
  [tv]:https://www.tidyverse.org/

We start by downloading the [shapefile for voting locations][vloc] from the City of Toronto's [Open Data portal][odata] and reading it with the `read_sf` function. Then, we pipe it to `st_transform` to set the appropriate [projection][proj] for the data. In this case, this isn't strictly necessary, since the shapefile is already in the right projection. But, I tend to do this for all shapefiles to avoid any oddities later.

  [vloc]:https://www.toronto.ca/city-government/data-research-maps/open-data/open-data-catalogue/#370e7072-0ba7-e477-121e-78ba5dac9649
  [odata]:https://www.toronto.ca/city-government/data-research-maps/open-data/
  [proj]:https://en.wikipedia.org/wiki/Map_projection

```{r toronto_shapefile, message=FALSE}
download.file("http://opendata.toronto.ca/gcc/voting_location_2018_wgs84.zip",
                destfile = "data-raw/voting_location_2018_wgs84.zip", quiet = TRUE)
unzip("data-raw/voting_location_2018_wgs84.zip", exdir="data-raw/voting_location_2018_wgs84")
toronto_locations <- sf::read_sf("data-raw/voting_location_2018_wgs84", 
                                 layer = "VOTING_LOCATION_2018_WGS84") %>%
  sf::st_transform(crs = "+init=epsg:4326")
toronto_locations
```

The file has `r dim(toronto_locations)[1]` rows of data across `r dim(toronto_locations)[2]` columns. The first `r dim(toronto_locations)[2]-1` columns are data within the original shapefile. The last column is a [list column][lc] that is added by `sf` and contains the geometry of the location. This specific design feature is what makes an `sf` object work really well with the rest of the tidyverse: the geographical details are just a column in the data frame. This makes the data much easier to work with than in other approaches, where the data is contained within an `@data` slot of an object.

  [lc]:https://www.rstudio.com/resources/videos/how-to-work-with-list-columns/

Plotting the data is straightforward, since `sf` objects have a `plot` function. Here's an example where we plot the number of voters (`VOTER_CNT`) at each location. If you squint just right, you can see the general outline of Toronto in these points.

```{r, echo = FALSE}
plot(toronto_locations["VOTER_CNT"])
```

What we want to do next is use the voting location data to aggregate the votes cast at each location into census tracts. This then allows us to associate census characteristics (like age and income) with the pattern of votes and develop our statistical relationships for predicting voter behaviour.

We'll split this into several steps. The first is downloading and reading the census tract shapefile.

```{r census_tracts, message=FALSE}
download.file("http://www12.statcan.gc.ca/census-recensement/2011/geo/bound-limit/files-fichiers/gct_000b11a_e.zip",
                destfile = "data-raw/gct_000b11a_e.zip", quiet = TRUE)
unzip("data-raw/gct_000b11a_e.zip", exdir="data-raw/gct")
census_tracts <- sf::read_sf("data-raw/gct", layer = "gct_000b11a_e") %>%
  sf::st_transform(crs = "+init=epsg:4326")
```

Now that we have it, all we really want are the census tracts in Toronto (the shapefile includes census tracts across Canada). We achieve this by intersecting the Toronto voting locations with the census tracts using standard R subsetting notation.

```{r intersect, message=FALSE}
to_census_tracts <- census_tracts[toronto_locations,]
```

And, we can plot it to see how well the intersection worked. This time we'll plot the CTUID, which is the unique identifier for each census tract. This doesn't mean anything in this context, but adds some nice colour to the plot.

```{r plot_intersection}
plot(to_census_tracts["CTUID"])
```

Now you can really see the shape of Toronto, as well as the size of each census tract.

Next we need to manipulate the voting data to get votes received by major candidates in the 2018 election. We take these data from the [`toVotes` package][votep] and arbitrarily set the threshold for major candidates to receiving at least 100,000 votes. This yields our two main candidates: John Tory and Jennifer Keesmaat.

  [votep]:https://github.com/Psepho/toVotes

```{r major_candidates}
major_candidates <- toVotes %>% 
  dplyr::filter(year == 2018) %>%
  dplyr::group_by(candidate) %>%
  dplyr::summarise(votes = sum(votes)) %>%
  dplyr::filter(votes > 100000) %>%
  dplyr::select(candidate)
major_candidates
```

Given our goal of aggregating the votes received by each candidate into census tracts, we need a data frame that has each candidate in a separate column. We start by joining the major candidates table to the votes table. In this case, we also filter the votes to 2018, since John Tory has been a candidate in more than one election. Then we use the `tidyr` package to convert the table from long (with one candidate column) to wide (with a column for each candidate).

```{r spread_votes, message=FALSE}
spread_votes <- toVotes %>%
  tibble::as.tibble() %>% 
  dplyr::filter(year == 2018) %>%
  dplyr::right_join(major_candidates) %>%
  dplyr::select(-type, -year) %>%
  tidyr::spread(candidate, votes)
spread_votes
```

Our last step before finally aggregating to census tracts is to join the `spread_votes` table with the `toronto_locations` data. This requires pulling the ward and area identifiers from the `PT_LNG_CD` column of the `toronto_locations` data frame which we do with some `stringr` functions. While we're at it, we also update the candidate names to just surnames.

```{r geo_votes, message=FALSE}
to_geo_votes <- toronto_locations %>%
  dplyr::mutate(ward = as.integer(stringr::str_sub(PT_LNG_CD, 1, 2)),
                area = as.integer(stringr::str_sub(PT_LNG_CD, -3, -1))) %>%
  dplyr::left_join(spread_votes) %>%
  dplyr::select(`Keesmaat Jennifer`, `Tory John`) %>%
  dplyr::rename(Keesmaat = `Keesmaat Jennifer`, Tory = `Tory John`)
to_geo_votes
```

Okay, we're finally there. We have our census tract data in `to_census_tracts` and our voting data in `to_geo_votes`. We want to aggregate the votes into each census tract by summing the votes at each voting location within each census tract. We use the `aggregate` function for this.

```{r aggregate, message=FALSE}
ct_votes_wide <- aggregate(x = to_geo_votes, 
                           by = to_census_tracts, 
                           FUN = sum)
ct_votes_wide
```

As a last step, to tidy up, we now convert the wide table with a column for each candidate into a long table that has just one candidate column containing the name of the candidate.

```{r tidy_votes}
ct_votes <- tidyr::gather(ct_votes_wide, candidate, votes, -geometry)
ct_votes
```

Now that we have votes aggregated by census tract, we can add in many other attributes from the census data. We won't do that here, since this post is already pretty long. But, we'll end with a plot to show how easily `sf` integrates with `ggplot2`. This is a nice improvement from past workflows, when several steps were required. In the actual [code for the retrospective analysis][code], I added some other plotting techniques, like cutting the response variable (votes) into equally spaced pieces and adding some more refined labels. Here, we'll just produce a simple plot.

  [code]:https://github.com/Psepho/to2018retrospective/blob/master/compare_pred_actual_2018.Rmd

```{r map}
ggplot2::ggplot(data = ct_votes) +
  ggplot2::geom_sf(ggplot2::aes(fill = votes)) +
  ggplot2::facet_wrap(~candidate)
```
